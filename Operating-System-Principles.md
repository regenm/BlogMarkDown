---
title: Operating System Principles
date: 2024-02-27 19:40:51
tags: [Operating System, 笔记]
categories: [软件技术]
---

==操作系统原理==

# 1.操作系统概论

# 2.操作系统接口
## 用户与操作系统接口的分类
1. 用户接口
	提供给用户使用，通过该接口取得操作系统的服务。
2. 程序接口
	提供给程序员使用，用户程序使用系统服务的唯一途径
	
### 用户接口（操作接口）
1. 联机用户接口（交互式）
2. 脱机用户接口（批处理 ）
#### 联机用户接口（交互式）
1. 字符显示式联机用户接口
* 命令行方式：shell 语言
* 批命令方式：.sh
2. 图形化联机用户接口
* GUI ：包括窗口，图标，菜单，鼠标和面向对象技术
#### 脱机用户接口（批处理 ）
	由一组作业控制语言组成。
* 作业：一次应用业务处理中，从输入开始到输入结束。用户要求计算机所做工作的集合。
* 作业步：作业加工处理的技术
* 作业分类：脱机作业，联机作业。
* 作业I/O方式：联机IO，脱机IO，SpooLing方式

## 系统调用
	系统调用（System Call），提供了用户程序和操作系统之间的接口。用户不能直接调用，但是用户程序可以。

### 作业

> * 作业：在一次应用业务处理过程中，从输入开始到输出结束，用户要求计算机所做工作的集合。
> * 作业步：作业加工处理的步骤。
> * 作业的分类：脱机作业、联机作业。
> * 作业的I/O 方式：联机I/O 、脱机I/O 、SpooLing方式。



### 特权指令和非特权指令

* 特权指令
	不允许用户程序直接使用的指令，关系到系统全局。
	特点：
	1. 内存访问范围不受限制
	2. 用户和系统存储空间都能访问
* 非特权指令
	只能完成一般性的操作和任务，不能直接访问系统的硬件和软件。
	访问范围局限于用户空间
	
### 管态和目态
1. 管态（系统态，核心态）：
	可以执行包括特权指令的所有机器指令。

2. 目态（用户态）：
	不允许执行特权指令。
	
### 系统调用
​	定义：系统调用是操作系统提供的一组用于实现各种系统功能的子程序，并将它们提供给应用程序调用。 

==系统调用是应用程序获得操作系统服务的唯一途径！==
* 系统调用会将用户态切换到内核态
* 执行完成后，系统又将CPU状态从系统态转换到用户态，再继续执行应用程序。
* 系统调用是一种特殊的过程调用，通常由特殊的机器指令实现。除了提供对操作系统子程序的调用外，这个指令还将系统转入特权方式（管态）。 

# 3. *进程管理

## *进程的基本概念
### 程序
* 程序的特征
1. 顺序性，处理机的操作严格按照程序所规定的顺序执行
2. 封闭性，程序运行时独占全机资源
3. 结果的确定性，执行结果和中断次数无关
4. 可再现性，只要程序顺序执行的环境和初始条件相同，不论执行过程如何，都将获得相同的结果
### 进程
#### 概念
* 非正式
	执行中的程序
	运行中的代码段 
* 正式
	可并发执行的程序在一个数据集合上的执行过程，是系统进行资源分配和调度的一个独立单位
	注意：进程 != 程序
### 进程与程序的关系
#### 比较

｜进程｜程序｜
｜-------｜-------｜
｜动态｜静态｜
｜并发｜顺序｜
｜暂时｜永久｜
* 出现原因：支持多道编程

#### 进程的特征（属性）
特征：
1. 结构特征
进程实体：由程序段、数据段、核心栈及进程控制块部分构成，总称“进程映像”（Process Image）。
2. 动态性(最基本的特征)
由“创建”而产生，由“调度”而执行；由得不到资源而阻塞；由撤消而消亡。（而程序是静态的）。
3. 并发性（重要特征）
只有建立了进程，才能并发执行。
4. 独立性
独立运行，独立获得资源、独立接受调度。
5. 异步性
进程按各自独立、不可预知的速度向前推进




## *进状态及转换
### 进程的三种基本状态
* 就绪状态
* 执行/运行状态
* 阻塞/等待/睡眠/暂停/封锁状态

###进程状态变迁情况及原因：

1. 就绪状态→运行状态：由OS中的进程调度程序，按一定的原则调度就绪队列中进程占用CPU。
2. 运行状态→就绪状态：时间片到，高优先进程进入就绪队列，等等。
3. 运行状态→阻塞状态：等待I/O传输，申请内存空间，程序运行出错，等等。
4. 阻塞状态→就绪状态： I/O传输完成，内存空间获得，程序运行错误处理完成，等等。
#### 进程的五态模型

1. NULL-创建态：新进程的产生
2. 创建态-就绪态：资源允许的情况
3. 执行态-终止态：自然结束，强行终止
4. 终止态-NULL：完成善后操作
5. 阻塞态-终止态：强行终止
6. 就绪态-终止态：强行终止

* 程序状态字PSW（程序状态寄存器）又称（标志寄存器）

​	PSW用来存放两类信息：一类是体现当前指令执行结果的各种状态信息，称为状态标志，如有无进位（CF位），有无溢出（OF位），结果正负（SF位），结果是否为零（ZF位），奇偶标志位（PF位）等；另一类是存放控制信息，称为控制状态，如允许中断(IF位)，跟踪标志（TF位），方向标志(DF)等。

## *进程控制

​	进程控制的职责是对系统中的全部进程实施有效的管理，它是处理机管理的一部分。





## 进程同步

### 进程之间的制约关系

1. 间接制约：资源竞争关系

需互斥地访问临界资源（进程互斥）

* 临界资源：在一个时间段内只允许一个进程访问的资源。
* 临界区（Critical Section，CS）进程访问临界资源的一段代码。

2. 直接制约：相互协作关系

### 进程间资源访问冲突

-共享变量的修改冲突

-操作顺序中冲突

### 进程之间的交互关系

1. 互斥：指多个进程不能同时使用同一个资源
2. 同步：进程之间的协作
3. 死锁：指多个进程互不相让，都得不到足够的资源；

### 锁

锁（共享的变量）阻止了其他进程进入临界区

### 临界区及其管理

​	临界区的执行在时间上是互斥的,进程必须请求允许进入临界区

间接同步（互斥）机制应遵循的准则

（1）空闲让进：当无进程处于临界区时，允许一进程立即进入临界区

（2）忙则等待：当某一进程已进入临界区时，其它试图进入临界区进程必须等待

（3）有限等待：应保证为有限等待，不会产生”死等”状态。（4）让权等待：不能进入临界区的执行进程应放弃CPU执行权。

#### 硬件方式-提供的低级原子级操作

1. 关中断

​	硬件上的关中断（禁止中断）。

* 缺点：
    * 影响计算机效率
    * 在多处理器下方法失效

### 进程死锁

> ​	进程死锁是指两个或多个进程在执行过程中，由于竞争系统资源而造成的一种僵局状态，导致它们永远无法继续执行下去。在死锁状态下，每个进程都在等待系统中的某个资源被释放，而释放该资源的操作又被其他进程所持有，从而导致所有进程都无法继续执行。换句话说，每个进程都在等待其他进程释放资源，而它们自身持有的资源又被其他进程等待，从而形成了一个相互等待的循环，无法解开。

### * 信号量机制（必考）

​	**定义**：信号量机制是操作系统中用于控制对共享资源访问的一种同步机制。它通常用于多进程或多线程环境下，以确保对共享资源的访问不会导致竞态条件或数据不一致的问题。

1. **P操作**
    获取信号量（P操作）：当一个线程或进程需要访问共享资源时，它需要首先尝试获取信号量。获取信号量的操作通常称为 P（或 wait）操作。如果信号量的值大于零，表示有可用的资源，线程或进程可以继续执行；如果信号量的值为零，表示资源已经被占用，线程或进程需要等待，直到有资源可用
2. **V操作**
    释放信号量（V操作）：当线程或进程使用完共享资源后，它需要释放信号量，以允许其他线程或进程继续访问。释放信号量的操作通常称为 V（或 signal）操作。通过增加信号量的值，V操作使得等待中的线程或进程可以继续执行。释放信号量（V操作）：当线程或进程使用完共享资源后，它需要释放信号量，以允许其他线程或进程继续访问。释放信号量的操作通常称为 V（或 signal）操作。通过增加信号量的值，V操作使得等待中的线程或进程可以继续执行。

#### * 信号量分类

**信号量分为：互斥信号量和资源信号量**

* 互斥信号量用于申请或释放资源的使用权，常初始化为1。
* 资源信号量用于申请或归还资源，可以初始化为大于1的正整数，表示系统中某类资源的可用个数。

1. 整形信号量
    1. 设S为一个需要初始化值的整型量，对S的访问仅能通过两个标准的原子操作P(S)和V(S)。**S的初值代表资源的总数**。
    2. 如果S的值为1，表示有1个临界资源可以使用。
    3. 整型信号量S是一个全局变量（整型初始非负），并发进程都能够访问。S需要在主程序中定义，并赋予初值。
2. 记录型信号量
    1. 在整型信号量的基础上进行改进
    2. 让不能进入临界区的进程“让权等待”，即进程状态由运行转换为阻塞状态，进程进入阻塞队列中等待。
    3. Semaphore为一个记录型数据结构
        1. **value：**代表资源数目，具有初值，该初值通常为非负整数。
        2. **L**：是一个初始状态为空的进程阻塞队列。
    4. 工作流程
        1. 记录型信号量的P操作是先减1，再测试，因此，测试条件是小于0，不是小于等于0；记录型信号量的V操作是先加1，再判断是否有进程阻塞，有进程阻塞则唤醒。
        2. 在P(S)操作中，S.value的值小于0时，表示不能访问临界资源，block(S.L)将调用P(S)的进程置成阻塞状态等待。
        3. 在V(S)操作中，S.value的值小于等于0时，表示有进程在阻塞队列等待临界资源，wakeup(S.L)将唤醒一个在阻塞队列等待的进程。
3. AND型信号量
    1. 进程需要的资源越多，出现死锁的可能性也越大
    2. 解决的办法：将进程所需要的资源一次性地全部分配给进程，等进程运行完后再全部一起释放。
    3. **缺点**
        1. 虽然用AND型信号量会避免进程死锁，但是，AND型信号量使得并发进程变为先后执行，进程之间的相互等待，使得系统整体性能降低。

4. 信号量集
    1. 使用原因：
        1. 当进程一次需要N个某类临界资源时，如果用记录型信号量，进程每次只能一次申请或释放一个临界资源，效率较低；每类资源数下限不同；对每类资源需求不同。因此引入信号量集：


### * 管程

#### 出现原因：

* 为了避免凡要使用临界资源的进程都自备同步操作P(s)和V(s), 将同步操作的机制和临界资源结合到一起，形成管程。

* 信号量能够解决的同步问题，用管程同样可以解决，而且更加简单

* 管程机制作为同步工具，便于在高级语言编程中实现。

#### 定义

* 一个数据结构和能为并发进程所执行的在该数据结构上的一组操作。

#### 结构

* 管程名
* 局部于管程内部的共享数据结构说明
* 对该数据结构进行操作的一组过程
* 对共享数据结构设置初始值

#### 使用

​	进程可在任何需要的地方调用管程中的过程，但不能在管程外直接访问管程内的数据结构

​	管程本身被作为一种临界区，因此，实现管程时，需要考虑互斥、同步和控制变量等问题

#### 特征

* 模块化。是基本程序单位，可单独编译；
* 抽象数据类型。管程中不仅有数据，还有对数据的操作；
* 信息封装。管程中的数据结构只能被管程中的过程访问，这些过程供管程外的进程调用，而管程中的数据结构以及过程的具体实现外部不可见。
* 任一时刻，在管程中只能有一个进程运行。调用管程中过程的进程进入管程，如果不能访问临界资源时，则不能继续运行，需要在管程中阻塞等待临界资源。此时，在管程外等待访问管程的另一个进程可以进入管程。

#### * 管程与进程的比较

* 管程定义的是公用数据结构，而进程定义的是私有数据结构;
* 管程把共享变量上的同步操作集中起来，而临界区却分散在每个进程中；
* 管程是为管理共享资源而建立的，进程主要是为占有系统资源和实现系统并发性而引入的；
* 管程是被欲使用共享资源的进程所调用的，管程和调用它的进程不能并行工作，而进程之间能并行工作，并发性是其固有特性；
* 管程是语言或操作系统的成分，不必创建或撤销，而进程有生命周期，由创建而产生至撤销便消亡。



## 进程通信

Inter Process Communication

### 管道

* 管道（pipe）用于相关进程之间的通信
* 管道类似于共享文件，位于外存区域，但在文件系统中不可见一个
    * 进程在文件的一端写入
    * 另一个进程从文件的另一端读出
    * 管道 I/O 类似于文件 I/O

#### 特点

* 管道通信效率低，不适合进程间频繁地交换数据。

#### 记名管道

* 用途：记名管道用于不相关进程之间的通信
* 特点
    * 一个有名字的通信管道 
    * 记名管道和文件系统共享一个名字空间
    * 易于在非相关进程间通信
    * 进程通过调用程序API创建记名管道

#### 分类

* 无名管道

    - 无名管道是一种临时的、单向的通信管道，只能在相关进程之间使用。

    - 无名管道在创建时不需要命名，因此也称为匿名管道。

    - 无名管道通常用于具有父子关系的相关进程之间进行通信。

* 命名管道
    * 命名管道是一种命名的、双向的通信管道，允许无关的进程之间进行通信。
    * 命名管道在创建时会关联一个特定的文件路径名，因此也称为FIFO（First In, First Out）。
    * 命名管道通常用于独立的进程之间进行通信，它们可以是同一台计算机上的不同进程，也可以是不同计算机上的进程。

### 套接字和信号

#### 信号（signal）:

* 向一个进程通知发生异步事件，类似于信号中断，但无优先级
* 一个进程发送到另一个进程的内核对象或内核数据结构
* 信号可以被捕获或者忽略



#### 套接字（socket）:

* 网络中不同主机上的应用进程之间进行双向通信的端点的抽象
* 一种类似于文件的通信模式
* 通信双方（服务器和客户端）均需要创建套接字
* 本地的或远程的
* 进程通过调用套接字API创建套接字

### 共享内存

共享存储器系统: 相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过这些空间进行通信。 

* 基于共享数据结构，低效，只能传递少量数据。(生产者-消费者问题) 
* 通过共享存储区  
* 一个进程创建一段共享内存  
* 其它进程可以将该片内存映射到自己的地址空间  
* 共享内存的任何改变对进程都可见

### 消息传递

 通过消息传递  应用最广泛的进程通信机制

##### 实现方式

1. 直接通信

* 发送进程利用OS所提供的发送命令，直接把消息发送给目标进程
* 发送进程和接收进程都以显式方式提供对方的标识符              Send(Receiver, message); 发送一个消息给接收进程；             Receive(Sender, message); 接收Sender发来的消息；      
* 例如，原语Send(P2, m1)表示将消息m1发送给接收进程P2; 而原语Receive(P1，m1)则表示接收由P1发来的消息m1

2. 间接通信

* 进程之间的通信需要通过作为共享数据结构的实体（信箱）

> 信箱：信箱可由操作系统创建，也可由用户进程创建，创建者是信箱的拥有者。据此，可把信箱分为以下三类
>
> * 私用信箱
>
> 用户进程可为自己建立一个新信箱，并作为该进程的一部分。信箱的拥有者有权从信箱中读取消息，其他用户则只能将自己构成的消息发送到该信箱中。这种私用信箱可采用单向通信链路的信箱来实现。 当拥有该信箱的进程结束时，信箱也随之消失
>
> * 公用信箱
>
> 由操作系统创建，并提供给系统中所有的核准进程使用。核准进程既可把消息发送到该信箱中，也可从信箱中读取发送给自己的消息。显然，公用信箱应采用双向通信链路的信箱来实现。通常，公用信箱在系统运行期间始终存在。
>
> * 共享信箱
>
> 它由某进程创建，在创建时或创建后，指明它是可共享的，同时须指出共享进程(用户)的名字。信箱的拥有者和共享者，都有权从信箱中取走发送给自己的消息
>
> 信箱通信模式
>
> * 一对一关系。为发送进程和接收进程建立一条两者专用的通信链路，使两者之间的交互不受其他进程的干扰。
> * 多对一关系。允许提供服务的进程与多个用户进程之间进行交互，也称为客户/服务器交互，这时信箱称为端口（port）。
> * 一对多关系。允许一个发送进程与多个接收进程进行交互，使发送进程可用广播方式，向多个接收者发送消息。
> * 多对多关系。允许建立一个公用信箱，让多个进程都能向信箱中投递消息；也可从信箱中取走属于自己的消息。 

* 信箱的创建和撤消进程可利用信箱创建原语来建立一个新信箱。创建者进程应给出信箱名字、信箱属性(公用、私用或共享)；对于共享信箱， 还应给出共享者的名字。当进程不再需要读信箱时，可用信箱撤消原语将之撤消。
* 消息的发送和接收当进程之间要利用信箱进行通信时，必须使用共享信箱，并利用系统提供的下述通信原语进行通信。

##### 消息传递系统实现中的若干问题

* 通信链路的建立

> 发送进程显式建立通信链路，主要用于计算机网络中使用系统的发送命令时，自动建立链路，主要用于单机系统中
>
> 通信链路分类:
>
> 1. 按照连接方式: 
>     1. 点-点连接
>     2. 多点连接
>
> 2. 按照通信方式
>     1. 单向通信链路
>     2. 双向通信链路

* 消息格式:消息传递系统中所传递的消息，必须具有一定的格式。

> 格式类型
>
> * 定长消息格式
>
>     可减少对消息的处理和存储开销。
>
> * 变长消息格式
>
>     方便发送较长消息的客户

* 同步方式

> 发送接收均阻塞（汇合）：发送进程和接受进程间无缓冲，平时处于阻塞态，直到有消息传递
>
> 发送不阻塞，接收阻塞：应用最为广泛。如服务器。
>
> 发送接收均不阻塞：不要求任何一方等待。



#### 三种方式比较

1.无名管道简单方便．但局限于单向通信的工作方式．并且只能在创建它的进程及其子孙进程之间实现管道的共享：有名管道虽然可以提供给任意关系的进程使用。但是由于其长期存在于系统之中，使用不当容易出错。

2.消息缓冲可以不局限于父子进程．而允许任意进程通过共享消息队列来实现进程间通信．并由系统调用函数来实现消息发送和接收之间的同步．从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题．使用方便，但是信息的复制需要额外消耗CPU的时间．不适宜于信息量大或操作频繁的场合。

3.共享内存利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。但是共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的．因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决。另外，由于内存实体存在于计算机系统中．所以只能由处于同一个计算机系统中的诸进程共享。不方便网络通信。

## 死锁

### 概念

多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。

> 资源：进程运行需要的事物计算机
>
> 资源的例子:  打印机，磁盘驱动器，数据表格，锁磁盘空间，内存，信号量，CPU

### 产生原因

1. 竞争资源引起死锁
2. 进程间推进顺序非法引起死锁

#### 竞争资源引起的进程死锁

* 可剥夺资源和不可剥夺资源

> 1. **可剥夺资源**：指的是系统可以在任意时刻剥夺并重新分配的资源。当一个进程占用了可剥夺资源时，操作系统可以在必要时将资源从该进程中取走，并分配给其他进程使用，以确保系统的公平性和效率。典型的可剥夺资源包括处理器（CPU）、内存和设备（如磁盘、网络接口）等。
> 2. **非剥夺资源**：指的是系统不会在任意时刻剥夺的资源。一旦分配给某个进程，就必须等到该进程主动释放资源或者完成执行后，才能将资源分配给其他进程。典型的非剥夺资源包括硬件设备中的某些控制器、I/O 设备中的某些部件等。

* 竞争非剥夺性资源，可造成死锁
*  竞争临时性资源。

> 临时性资源是指由一个进程产生，被另一个进程使用一段时间后便无用的资源。

#### 进程推进顺序不当引起死锁

### 产生条件

1. 互斥条件: 某资源在一段时间内只能由一个进程占用
2. 持有等待: 线程在请求新的资源时，其已经获得的资源并不释放，而是继续持有
3. 不能抢占不能强迫进程放弃资源
4. 环路等待条件

### 处理死锁的基本方法

1. 不予理睬: 忽略问题的存在
2. 静态预防: 消除死锁发生的4个必要条件中的任何一个。
3. 动态避免: 仔细的资源分配
4. 死锁检测与解除让死锁出现然后采取措施去纠正

#### 不予理睬: 忽略问题的存在

* 假装没有问题，“鸵鸟算法”

* 此种策略在如下情况下是合理的 

    1. 死锁出现的概率很低 

    2. 预防死锁的代价很大

* UNIX 和Windows都采取这种方法方便和正确性之间的一种折中

#### 静态预防: 消除死锁发生的4个必要条件中的任何一个。

* 消除四个条件中的一个
    * 消除资源独占条件

> 原则:
>
> 1. 不是绝对必须的时候避免分配资源
> 2. 尽可能少的进程获得资源

* 消除持有和等待条件

> 进程在启动之前请求所有的资源
>
> * 特点
>
> 等待所有你需要的资源都被释放然后一次都获取它们B. 如果获取资源失败释放所有已经拥有的资源
>
> * 缺点
>
> 一次获取所有的资源，造成资源浪费开始运行的时候可能不知道所有需要的资源

* 消除非抢占条件

>1. 允许抢占
>2. 可以抢占 CPU ：通过将信息保存到进程控制表，之后再恢复它。
>3. 可以抢占内存 通过把内存倒出到磁盘上，之后再把它装回
>
>* 局限性：有些资源不可以被抢占，比如锁打印机

* 消除环路等待条件

> * 环路等待的原因是由于进程请求资源的顺序是随机的
>
> * 可以通过定义资源类型的线性顺序来预防

* 增加资源从而减少等待
    * 最小化了死锁的几率

#### 动态避免: 仔细的资源分配



#### 死锁检测与解除让死锁出现然后采取措施去纠正

* 注意资源的占有和资源需求
* 通过查看有向图中的循环来检查死锁

**矩阵检测**

矩阵检测的基本思想是将系统中的资源和进程状态抽象为一个矩阵，其中矩阵的行代表进程，列代表资源。这样，可以通过观察矩阵的状态来分析系统中是否存在资源分配问题（如死锁）或者资源使用情况是否合理。

在矩阵检测中，有两个主要的概念：

1. **资源分配矩阵（Resource Allocation Matrix）**：该矩阵显示了系统中各个进程对资源的请求以及已经被分配的资源情况。行表示进程，列表示资源，矩阵中的每个元素表示某个进程对某个资源的请求或分配情况。
2. **需求矩阵（Demand Matrix）**：需求矩阵显示了每个进程对资源的需求情况。与资源分配矩阵相比，需求矩阵中的每个元素表示某个进程对某个资源的需求量。

通过分析这些矩阵，可以发现潜在的问题，例如：

- **死锁检测**：通过观察资源分配矩阵和需求矩阵，可以检测系统中是否存在死锁。如果存在某个进程无法满足其资源需求，同时该资源被其他进程占用，那么可能发生死锁。
- **资源分配优化**：通过观察资源分配矩阵，可以发现资源使用效率低下的情况，进而优化资源分配策略，提高系统整体的性能。

### 死锁的恢复

1. 抢占

* 将某个进程所占的资源强行拿走
* 取决于资源的性质

2. 上翻

* 定期检查进程
* 上翻到一个安全的状态 
* 如果发现死锁重启进程

3. 杀死进程

* 中断进程的最简单方法
* 杀死死锁循环中的一个进程
* 其他进程获得它的资源 
* 选择可以重新开始运行的进程

### *死锁的动态避免

#### 死锁的动态避免原则：

使用资源规划，确保该资源请求批准后系统不会进入到死锁或者潜在的死锁状态。

>* 状态分类为：**安全状态**和**不安全状态**
>
>1. 安全状态
>    * 指系统能按某种进程顺序（P1，P2，…，Pn），来为每个进程Pi分配其所需要资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺利完成。
>2. 不安全状态

#### 银行家算法

* 特点
    * 实现动态避免死锁
    * 类似于一开始就预留所有的资源，但是更加高效

* 介绍：

1. 事先声明所需的最大资源，但实际上并不获得资源
2. 当之后进程要求资源时, 银行家算法的策略:
    * 安全状态下满足要求
    * 如果处于不安全状态则阻塞进程



## 线程

### 进程的缺陷

* 一个进程在一个时间只能做一件事情

* 阻塞将使进程挂起，整个进程都无法继续执行

### 线程产生的原因

#### 进程的基本属性

1. 进程是拥有资源的独立单位.
2. 进程是独立调度和分派的基本单位

进程是资源拥有者，因而在进程的创建、撤消和切换中系统必须为之付出较大的时间、空间开销。因此，系统中所设置的进程的数目不宜过多，进程切换的频率不宜过高。这就限制了进程并发程度的提高。

=> 将进程的两个基本属性分开

### 线程的概念

线程是进程中的一个实体，是系统独立调度和分派的基本单位。

### 线程的属性

1. 轻型实体。 
2. 独立调度和分派的基本单位。 
3. 可并发执行。 
4. 共享进程资源。 

### 资源的共享与独享

1. 有些资源被进程内所有的线程共享

2. 有些资源是每个线程独享的

| **线程共享资源**   | **线程独享资源** |
| ------------------ | ---------------- |
| 地址空间           | 程序计数器       |
| 全局变量           | 寄存器           |
| 打开的文件         | 栈               |
| 子进程             | 状态字           |
| 闹铃               |                  |
| 信号及信号服务程序 |                  |
| 记账信息           |                  |

### 线程状态

#### 状态参数（Threaded Control Block，TCB）

在OS中的每一个线程都可以利用线程标识符和一组状态参数进行描述。状态参数通常有：

① 寄存器状态， 它包括程序计数器PC和堆栈指针中的内容； 

② 堆栈， 在堆栈中通常保存有局部变量和返回地址； 

③ 线程运行状态， 用于描述线程正处于何种运行状态；

④ 优先级， 描述线程执行的优先程度； 

⑤ 线程专有存储器， 用于保存线程自己的局部变量拷贝； 

⑥ 信号屏蔽， 即对某些信号加以屏蔽。 

#### 三种基本状态

①执行状态，表示线程正获得处理机而运行；

②就绪状态，指线程已具备了各种执行条件，一旦获得CPU便可执行的状态；

③阻塞状态，指线程在执行中因某事件而受阻，处于暂停执行时的状态。  

### 线程的创建和终止

* 创建

在多线程OS环境下，应用程序在启动时，通常仅有一个线程在执行，该线程被人们称为“初始化线程”。它可根据需要再去创建若干个线程。在创建新线程时，需要利用一个线程创建函数（或系统调用），并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程创建函数执行完后，将返回一个线程标识符供以后使用。

* 终止

终止线程的方式有两种：一种是在线程完成了自己的工作后自愿退出；另一种是线程在运行中出现错误或由于某种原因而被其它线程强行终止。 

### 多线程操作系统中的进程

在多线程OS中，进程是作为拥有系统资源的基本单位，通常的进程都包含多个线程并为它们提供资源，但此时的进程就不再作为一个执行的实体。多线程OS中的进程有以下属性：       

(1) 作为系统资源分配的单位。        

(2) 可包括多个线程。        

(3) 进程不是一个可执行的实体。 

### 线程的实现方式

1. 内核态线程的实现（Windows XP、IBM OS/2）
2. 用户态线程的实现（Java，Informix）
3. 组合实现（Solaris）

#### 内核态线程的实现（Windows XP、IBM OS/2）

* 完全在内核空间实现
* 内核空间设置线程控制块OS 
* 进行线程调度、资源分配等
* OS 维护线程的信息

> 优缺点：
>
> * 优点
>
> 1. 多处理器系统中，内核能同时调度同一进程中多个线程并行执行。
> 2. 阻塞线程不会阻塞进程。
> 3. 内核态线程具有很小的数据结构和堆栈，线程切换快，切换开销小。
> 4. 内核本身可采用多线程技术，提高系统执行速度和效率。
>
> * 缺点
>
> 1. 多处理器系统中，内核能同时调度同一进程中多个线程并行执行。
> 2. 阻塞线程不会阻塞进程。
> 3. 内核态线程具有很小的数据结构和堆栈，线程切换快，切换开销小。
> 4. 内核本身可采用多线程技术，提高系统执行速度和效率。

#### 用户态线程的实现（Java，Informix）

* 在用户空间实现。用户空间建立线程库：一组管理线程的过程
* 用户自己写执行系统进行调度。
* 线程自愿合作。
* 操作系统不知道线程的存在，     其调度仍以进程为单位执行。

> 优缺点：
>
> 1. 优点
>
> 1. 线程切换快：不需要陷入到内核空间
> 2. 线程调度是应用程序特定的：可以选择最好的算法
> 3. 灵活性，可以在任何操作系统上实现
>
> 1. 缺点
>
> 1. 编程困难
> 2. 多线程应用不能利用多处理机提高并行效率
> 3. 系统调用的阻塞问题，线程受阻导致整个进程受阻!

#### 组合实现（Solaris）

* 执行系统管理用户态线程
* 操作系统管理内核态线程
* 用户态线程被多路复用到内核态线程上

##### Solaris

Solaris的多线程模型中包括四种实体：进程，内核线程，用户线程和轻量级进程（Light Weight Process，LWP）

* Solaris内核是多线程的
    * 进程是资源分配和管理的单元
    * 内核级线程是内核的调度单元
    * 用户级线程是程序执行在用户态的抽象
    * LWP把用户线程和内核线程绑定到一起：

### 多线程

多线程是指在单个进程内同时执行多个线程的并发编程模型。每个线程是进程中的独立执行路径，它可以独立执行任务，并且共享相同进程的资源，如内存空间、文件句柄等。多线程的主要优势包括提高系统资源利用率、增加程序响应速度、简化编程模型等。

以下是多线程的一些重要概念和特点：

1. **并发性**：多线程允许多个任务同时执行，提高了系统的并发性。每个线程独立执行，它们之间可以并发执行，从而实现了程序的并行处理。
2. **共享内存**：在多线程编程中，各个线程共享同一进程的内存空间。这意味着线程可以方便地共享数据，但也需要考虑线程间的同步和互斥，以避免数据竞争和不一致的情况。
3. **轻量级**：与进程相比，线程是更轻量级的执行单元。创建和销毁线程的开销比创建和销毁进程要小得多，因此多线程通常更适合于处理大量的并发任务。
4. **并行性**：多线程可以在多核处理器上实现并行执行，从而提高了程序的性能。在具有多个核心的系统中，不同线程可以在不同的核心上并行执行，从而更有效地利用系统资源。
5. **线程同步**：多线程编程需要考虑线程之间的同步和互斥问题。当多个线程访问共享资源时，需要使用同步机制来保证数据的一致性，例如使用锁、信号量、条件变量等。
6. **线程调度**：线程的调度由操作系统负责，操作系统根据线程的优先级和调度算法来确定线程的执行顺序。不同的操作系统可能有不同的线程调度策略。

多线程广泛应用于各种计算机应用中，包括服务器编程、图形界面程序、游戏开发、数据处理等。它提供了一种有效的方式来处理并发任务，提高系统的性能和响应速度。

#### 线程之间的通信

##### 共享内存

在共享内存模型中，多个线程共享同一进程的内存空间。线程可以通过读写共享内存来进行通信。常见的共享内存通信方式包括：

1. **互斥锁（Mutex）**：使用互斥锁来保护共享资源，只有获取锁的线程可以访问共享资源，其他线程需要等待直到锁被释放。这样可以防止多个线程同时修改共享资源导致的数据竞争问题。
2. **条件变量（Condition Variable）**：条件变量用于在线程之间传递信号，允许线程等待某个条件变为真。一个线程可以在条件变量上等待，而另一个线程可以通过发送信号来通知等待的线程条件已经满足。
3. **信号量（Semaphore）**：信号量是一种计数器，用于控制对共享资源的访问。它可以确保多个线程不会同时访问临界区，从而避免竞争条件。

##### 消息传递

在消息传递模型中，线程之间通过发送消息来进行通信，而不共享内存。常见的消息传递通信方式包括：

1. **消息队列（Message Queue）**：线程可以通过向消息队列发送消息或者从消息队列接收消息来进行通信。消息队列可以是进程内的，也可以是跨进程的。
2. **管道（Pipe）**：管道是一种特殊的文件，用于进程间通信。线程可以通过管道来发送和接收数据。
3. **套接字（Socket）**：套接字是在网络编程中使用的一种通信机制，它也可以在同一台主机的不同线程之间进行通信。
4. **消息传递接口（MPI）**：MPI是一种用于并行计算的标准通信库，它提供了一套丰富的消息传递函数，用于在并行计算中进行进程间通信。

#### 线程之间的同步

#####  互斥锁（Mutex）

互斥锁是一种最常见的线程同步机制。它用于保护共享资源，一次只允许一个线程访问共享资源。线程在访问共享资源之前会尝试获取互斥锁，如果成功获取，则可以访问资源，否则会阻塞直到锁可用。

##### 2. 条件变量（Condition Variable）

条件变量允许一个线程等待某个条件为真，当条件为真时，另一个线程可以通过发送信号来通知等待线程。它通常与互斥锁一起使用，用于实现线程间的等待和唤醒机制。

##### 3. 信号量（Semaphore）

信号量是一个计数器，用于控制对共享资源的访问。它可以用来限制同时访问某一资源的线程数量。信号量通常用于解决生产者-消费者问题等场景。

##### 4. 屏障（Barrier）

屏障用于等待多个线程都到达某一点之后再继续执行。当所有线程都到达屏障点时，它们会被释放，然后继续执行后续操作。

##### 5. 自旋锁（Spin Lock）

自旋锁是一种不会阻塞线程的锁，当一个线程尝试获取锁时，如果锁已被其他线程占用，它会一直自旋等待直到锁可用。自旋锁适用于锁被持有时间短、并发度高的情况。

##### 6. 读写锁（Read-Write Lock）

读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种锁适用于读操作远远多于写操作的情况，可以提高并发性能。

##### 7. 原子操作（Atomic Operation）

原子操作是一种不可中断的操作，它可以保证在多线程环境下对共享变量的操作是原子的，从而避免了数据竞争问题。

## 经典例题

### 	生产者消费者问题

### 	读者写者问题

### 	哲学家进餐问题

# 4. *处理机调度

## 基本概念

==处理机调度指在多道程序环境下将处理机分配给各**进程**==

### 作业

#### 作业概念

作业：作业是用户在一次解题或一个事务处理过程中要求计算机系统所做工作的集合，包括用户程序、所需的数据及命令等。

作业由一组统一管理和操作的进程集合构成，是用户要求计算机系统完成的一项相对独立的工作。

#### 作业分类

##### 按需要处理工作的类型

1. 计算型作业

    >- **特点**：
    >    - 计算密集型作业是指需要大量的 CPU 计算资源来完成的任务。
    >    - 这类作业通常不需要太多的输入输出操作，而是以大量的计算为主。
    >    - 例如，科学计算、数值模拟、图形渲染等任务就属于计算密集型作业。
    >- **特征**：
    >    - 需要大量的 CPU 计算时间，但相对较少的 I/O 操作。
    >    - 对 CPU 的利用率较高，但是可能会导致其他任务在等待 CPU 资源时出现阻塞。
    >- **优化**：
    >    - 优化计算算法和数据结构，以减少计算时间和资源消耗。
    >    - 可以采用并行计算的方式，利用多核处理器或分布式计算集群来加速计算过程。
    >
    >

2. I/O型作业

    >- **特点**：
    >    - I/O 密集型作业是指需要大量的输入输出操作来完成的任务。
    >    - 这类作业通常对 CPU 的要求不高，但需要大量的数据传输和处理。
    >    - 例如，文件操作、网络通信、数据库查询等任务就属于 I/O 密集型作业。
    >- **特征**：
    >    - 需要大量的输入输出操作，而计算操作相对较少。
    >    - 对 CPU 的利用率较低，但可能会导致 CPU 等待 I/O 操作完成而出现阻塞。
    >- **优化**：
    >    - 优化 I/O 操作，减少等待时间，例如使用异步 I/O、缓存等技术。
    >    - 可以采用多线程或事件驱动的方式来处理并发的 I/O 操作，提高系统的响应性。

##### 按作业提交的方式不同

1. 批处理作业

    >- **特点**：
    >    - 批处理作业是一组按顺序排列的任务，通常一次性提交给系统执行，而无需用户交互。
    >    - 这些作业通常是长时间运行的，不需要实时用户交互。
    >    - 作业提交后，系统会按照作业的顺序执行，并在完成后将结果输出到指定的输出设备或文件。
    >- **应用场景**：
    >    - 批处理作业适用于一些需要大量计算和处理时间的任务，如大规模数据处理、科学计算、批量文件处理等。
    >    - 典型的批处理作业包括数据分析、报表生成、批量图像处理等。
    >- **优点**：
    >    - 可以高效地利用计算机资源，减少用户等待时间。
    >    - 可以自动化执行，无需用户交互，提高了系统的整体效率。

2. 终端型作业

    >- **特点**：
    >    - 交互式作业是需要用户实时交互的任务，用户可以在程序执行过程中输入命令、进行数据输入或查看输出。
    >    - 这些作业通常需要较短的响应时间，以满足用户实时操作的要求。
    >- **应用场景**：
    >    - 交互式作业适用于需要用户实时交互和反馈的任务，如命令行界面、图形用户界面、文本编辑器等。
    >    - 典型的交互式应用包括操作系统的命令行界面、办公软件、图像编辑器等。
    >- **优点**：
    >    - 提供了实时的用户交互体验，可以根据用户的需求动态调整程序行为。
    >    - 可以与用户直接交互，满足用户个性化的需求。

#### 作业控制块（Job Control Block，JCB）

JCB是作业在系统中存在的标志

* 作业步：每个作业都要经过若干个相对独立而又相互关联的顺序加工步骤才能得到结果，每一个步骤称为一个作业步。
* 作业流：若干个作业进入系统后被依次存放在外存上，形成了输入的作业流。
* 作业的状态：一个作业进入系统到运行结束，一般需要经历收容、运行、完成三个阶段，与之相对应的是作业的三种状态（批处理作业）： 
    * 后备状态 
    * 运行状态 
    * 完成状态

#### 作业和进程的关系

==作业是任务实体，进程是完成任务的执行实体==

==作业概念更多地用在批处理操作系统，而进程则可以用在各种多道程序设计系统。==



## 处理机调度的层次



### 低级调度（进程调度（Process Scheduling））

低级调度概念

进程调度是处理机调度的最低层次，负责决定哪个**进程**将获得 CPU 的使用权。

#### 低级调度特征

* 主要任务是按照某种策略和方法选取一个处于就绪状态的进程，将处理机分配给它
* 低级调度的时间尺度通常是毫秒级的。由于低级调度算法的频繁使用，要求在实现时做到高效
* 常见的低级调度有非抢占式和抢占式两种

> * **非抢占方式(Non-preemptive)**把处理机分配给某进程后，便让其一直执行，直到该进程完成或发生某事件而被阻塞时，才把处理机分配给其它进程，不允许其他进程抢占已经分配出去的处理机。
>
> > **优点:**实现简单、系统开销小，适用于大多数批处理系统环境；
> >
> > **缺点:**难以满足紧急任务的要求，不适用于实时、分时系统要求
> >
> > **引起进程调度的因素**：
> >
> > 1. 正在执行的进程执行完毕，或因发生某事件而不能再继续执行
> > 2. 执行中的进程因提出I/O请求而暂停执行
> > 3. 在进程通信或同步过程中执行了某种原语操作，如Block、Wakeup原语
>
> * **抢占方式(Preemptive)**允许调度程序根据某个原则，去停止某个正在执行的进程，将处理机重新分配给另一个进程。
>
> >**优点:**适于时间要求严格的实时系统
> >
> >**缺点:**调度算法复杂，系统开销大
> >
> >**抢占式调度主要有以下原则：**
> >
> >1. 优先权原则：允许高优先权的新到进程抢占当前进程的处理机
> >2. 短作业(进程)优先原则：允许执行时间短的新到进程抢占当前进程的处理机 
> >3. 时间片原则：时间片用完后停止执行，重新进行调度，适用于分时系统 
>
> 

### 中级调度（Medium-term Scheduling）

#### 目的

​	为了提高内存利用率和系统吞吐量。使那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们调至外存上去等待。

#### 任务

​	按照给定的原则和策略，将处于外存对换区中重要的又具备运行条件的就绪进程调入内存，或将处于内存就绪状态或内存阻塞状态的进程交换到外存对换区。



### 高级调度（作业调度（Job Scheduling）

#### 定义

作业调度是处理机调度的最高层次，负责从外存中选择作业并将其调入内存，以便进一步执行。

#### 目的

1. 最大化系统的吞吐量和效率，即尽可能地保持 CPU 处于忙碌状态，
2. 同时避免资源的空闲浪费。

#### 主要任务

​	按一定的原则对外存上处于后备状态的作业进行选择，给选中的作业分配内存、输入/输出设备等必要的资源，并建立相应的进程，放入就绪队列，以使该作业的进程获得竞争处理机的权利

#### 

## 进程调度的时机

1. 当一个进程运行完毕或由于某种错误而终止运行
2. 当一个进程在运行中处于等待状态（等待I/O）
3. 分时系统中时间片到（就绪）
4. 可抢占下，当有一个优先级更高的进程就绪  例如：新创建一个进程，或一个阻塞进程变成就绪
5. 在进程通信中，执行中的进程执行了某种原语操作（P操作，阻塞原语）

## 进程的切换

只要OS取得对CPU的控制，进程切换就可能发生: 

1. 超级用户调用来自程序的显式请求 (如：打开文件)，该进程通常会被阻塞 
2. 陷阱最末（新）一条指令导致出错，会引起进程移至退出状态 
3. 中断 外部因素影响当前指令的执行，控制被转移至IH（中断处理程序）

## 调度队列模型

### 分类

1. 仅有进程调度的调度队列模型
2. 具有高级和低级调度的调度队列模型
3. 同时具有三级调度的调度队列模型

### 仅有进程调度的调度队列模型

* 在分时系统中，通常仅设有进程调度
* 系统把这些进程组织成一个就绪队列
* 每个进程在执行时，可能有以下几种情况：进
    * 程获得CPU正在执行
    * 任务在给定时间片内已完成，释放处理机后为完成状态
    * 任务在时间片内未完成，进入就绪队列末尾
    * 在执行期间因某事件而阻塞

### 具有高级和低级调度的调度队列模型

在批处理系统中，不仅需要进程调度，而且还要有作业调度

* 就绪队列的形式在批处理系统中，常用高优先权队列。进程进入就绪队列时，按优先权高低插入相应位置，调度程序总是把处理机分配给就绪队列首进程
* 设置多个阻塞队列根据事件的不同设置多个队列提高效率

### 同时具有三级调度的调度队列模型

这种模型一般包括以下三个调度队列：

#### 1. 高优先级队列（High Priority Queue）：

- **特点**：
    - 这个队列用于存放优先级较高的进程，例如实时进程或紧急任务等。
    - 这些进程通常要求立即执行，因此会被优先调度。
- **调度策略**：
    - 可能采用最高响应比优先（HRRN）或优先级调度等策略。

#### 2. 中优先级队列（Medium Priority Queue）：

- **特点**：
    - 这个队列用于存放普通优先级的进程，即不属于高优先级或低优先级的进程。
    - 这些进程的执行不是很紧急，但也不能被忽视。
- **调度策略**：
    - 可能采用轮转调度（Round Robin）等策略，以平衡各个进程之间的执行时间。

#### 3. 低优先级队列（Low Priority Queue）：

- **特点**：
    - 这个队列用于存放优先级较低的进程，例如后台任务或者长时间运行的任务。
    - 这些进程的执行不紧急，通常在其他任务执行完毕后才会被调度执行。
- **调度策略**：
    - 可能采用先来先服务（FCFS）等策略，确保这些任务不会长时间被阻塞。

#### 调度过程：

- 当系统空闲时，调度器会首先从高优先级队列中选择一个进程执行。
- 如果高优先级队列为空，调度器则会从中优先级队列中选择进程执行。
- 当高优先级或中优先级队列中的进程执行完毕或者发生阻塞时，调度器会从低优先级队列中选择一个进程执行。
- 进程从低优先级队列中执行完毕后，如果没有更高优先级的进程需要执行，则继续选择低优先级队列中的下一个进程执行。

## 调度目标

### 不同类型系统的调度目标

1. 批处理系统

    >系统吞吐率:最大化单位时间的工作量
    >
    >周转时间:最小化任务提交到结束之间的时间
    >
    >CPU 利用率:保持CPU始终处在繁忙工作状态
    >
    >

2. 交互式系统

    > 响应时间—快速响应需求
    >
    > 适度性—满足用户期望

3. 实时系统

    >满足截止时间—避免丢失数据
    >
    >提供性能可预测性

### 不同使用模式的调度目标

1. 对于计算密集型程序，极大化系统吞吐量

    * 单位时间内完成尽可能多的程序

2. 对于I/O密集型程序，极小化平均响应时间

    ​	* 平均化完成每项工作的时间

3. 对于平衡性程序，响应时间和周转时间之间的平衡

    * 各进程之间以某种平等的方式共享 CPU

## 调度算法

### 先来先服务(First Come First Served，FCFS)

按照作业/进程进入系统的先后次序进行调度，先进入系统者先调度；即启动等待时间最长的作业/进程

是一种最简单的调度算法，既可用于作业调度，也可用于进程调度

* 周转时间：完成时间-到达时间

* 带权周转时间：周转时间/服务时间

#### 优缺点

1. 优点
    1. 有利于长作业（进程）
    2. 有利于CPU繁忙型作业（进程）
    3. 用于批处理系统
2. 缺点
    1. 不利于短作业（进程）
    2. 不利于I/O繁忙型作业（进程）
    3. 不适于分时系统





### 短作业(进程)优先（Short Job\Process First，SJF\SPF）

以要求运行时间长短进行调度，即启动要求运行时间最短的作业

* 短作业优先调度算法SJF，是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行； 

* 短进程优先调度算法SPF，则是从就绪队列中选出一估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时，再重新调度。

#### 缺点

1. 对长作业不利。严重的是，若一长作业(进程)进入系统的后备队列(就绪队列)，由于调度程序总是优先调度那些(即使是后进来的)短作业(进程)，将导致长作业(进程)长期不被调度——饥饿
2. 完全未考虑作业(进程)的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理
3. 由于作业(进程)的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。



### 高优先权优先（Highest Priority First，HPF）

优先权调度算法的类型

1. 非抢占式优先权调度算法
2. 抢占式优先权调度算法

#### 非抢占式优先权调度算法

特点：系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成，或因发生某事件使该进程放弃处理机时，系统才将处理机重新分配给另一优先权最高的进程

主要用于批处理系统中，也可用于某些对实时性要求不严格的实时系统中



#### 抢占式优先权调度算法

特点：把处理机分配给优先权最高的进程，但在执行期间，只要出现另一个优先权更高的进程，则进程调度程序就立即停止当前进程的执行，并将处理机分配给新到的优先权最高的进程

注意：只要系统中出现一个新的就绪进程，就进行优先权比较

该调度算法，能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中

#### 优先权的类型

1. 静态优先权

    > 静态优先权在创建进程时确定，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0～7或0～255， 又把该整数称为优先数
    >
    > 特点：系统开销小、不够精确、一般用在要求不高的系统中

2. 动态优先权

>随进程的推进或随其等待时间的增加而改变，以获得更好的调度性能
>
>具有相同优先权初值的进程，则最先进入就绪队列的进程，将因其动态优先权变得最高而优先获得处理机，此即FCFS算法
>
>具有各不相同的优先权初值的就绪进程，则优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机
>
>当采用抢占式优先权调度算法时，如果再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机

### 高响应比优先（Highest Response First，HRF）

高响应比优先调度算法是FCFS和SJF的结合，克服了两种算法的缺点

调度策略：响应比最高的作业优先启动
$$
优先权=\frac{等待时间+要求服务时间}{要求服务时间}
$$
又可表示为
$$
优先权=\frac{响应时间}{要求服务时间}
$$

#### 缺点：要进行响应比计算，增加了系统开销

### 基于时间片的轮转调度算法(Round Robin，RR)

系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片；当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便停止该进程的执行，并将其放就绪队列尾；然后，再把处理机分配给就绪队列中新的队首；

时间片的大小从几ms到几百ms。

#### 优缺点

* 优点：公平。保证就绪队列中所有进程在一给定的时间内，均能获得一时间片的处理机执行时间
* 缺点：紧迫任务响应慢。UNIX中采用：时间片+优先权
* 时间片轮转策略特别适合于分时系统中使用

#### 时间片长度的确定

* 过长：退化为FCFS 算法，进程在一个时间片内都执行完，响应时间长。  
* 过短：用户的一次请求需要多个时间片才能处理完，上下文切换次数增加，系统开销大。
* 最佳的时间片量值应能使分时用户得到好的响应时间

### 多级反馈队列调度算法

#### 概念

设置多个就绪队列，并为各个队列赋予不同的优先级

第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低

该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍



* 一个进程永久分到一个队列，每个队列有自己的调度算法
* 前台的就绪队列是交互性作业的进程，采用时间片轮转。
* 后台的就绪队列是批处理作业的进程，采用优先权或短作业优先算法。
* **调度方式**有两种： 优先调度前台，若前台无可运行进程，才调度后台 分配占用CPU的时间比例，如：前台80%，后台20%

#### 性能

* 终端型作业用户终端型作业用户所提交的作业多属于交互型作业，通常较小，系统只要能使这些作业在第一队列所规定的时间片内完成即可 
* 短批处理作业用户若在第1队列中执行一个时间片即可完成，便可获得与终端型作业一样的响应时间如在第一个队列中不能完成，只需在第2、3队列中各执行一个时间片 
* 长批处理作业用户长作业将依次在第1，2，3…，n队列中执行，最终按轮转方式运行

### 其他调度算法

1. **保证调度**保证每个进程享用CPU的时间完全一样，即如果系统中共有n个进程，保证每个进程使用 1/n  CPU 时间（需要计算CPU获得比率）。
2. 彩票调度概率调度算法，发布一定数量的彩票给相应的进程，调度器每次随机抽取一张，彩票数量多的进程获得CPU的概率就大。
3. **用户公平调度**按照每个用户而不是每个进程来公平分配CPU。如果一个用户的进程数量多，则其所拥有的每个进程获得CPU时间将短。
4. **混合调度算法** (Multiple queue)将优先级分类各类内部采用轮转调度动态调整进程的优先级类别（否则产生饥饿）

### 实时调度

#### 基本条件

1. 提供必要的调度信息
    * 就绪时间
    * 开始/完成截止时间；
    * 处理时间；
    * 资源要求；
    * 优先级；
2. 系统处理能力强
3. 采用抢占调度方式
4. 具有快速切换机制

#### 最早截止时间优先算法（EDF）

最早截止时间优先算法（EDF）根据任务的截止时间来确定任务的优先级

总是运行最早结束的作业

如果一个新到达的进程比正在运行的进程截止期靠前非抢占：非周期实时任务抢占：周期实时任务

#### 最低松弛度优先LLF算法

松弛度：若A进程需在200ms时完成，其本身运行需要100ms，当前时刻是10ms，则A的松弛度为：200－100－10＝90松弛度=截止时间-要求服务时间-当前时刻主要用于可抢占的调度方式中例：两个周期性实时任务A、B，任务A每20ms执行一次，执行时间是10ms；任务B每50ms执行一次，执行时间是25ms。



# 5. *存储管理



## 存储器的层次结构

* 内存架构
    1. CPU寄存器: 低容量、高速度、高价格
    2. 主存: 中容量、中速度、中价格
    3. 辅存: 大容量、低速度、低成本

### 1. 处理器寄存器 register

​	用于存储处理器中与控制流和数据流相关的信息。访问速度最快，价格十分昂贵，存储空间非常有限，只能存储少量信息。

### 2. 高速缓存cache

​	为了解决处理器与内存之间速度不匹配而引入的存储空间。其存储容量比处理器寄存器大，访问速度比内存快。如果高速缓存的访问命中率高，则处理器从整体上以接近高速缓存的速度访问存储器，明显快于访问内存。

### 3. 内存  main memory

​	也称为主存。内存中存放有处理器执行时所需要的代码和数据。内存空间远远大于高速缓存空间。一个计算机系统中所配置内存的大小是衡量计算机系统性能的一个非常重要的指标。



### 4. 外存 secondary memory

​	外存是计算机系统中最大规模的存储器，存储有计算机系统所需要的各种软件资源。包括各种磁盘、磁带、光盘以及其他移动存储设备。磁盘中的硬盘是计算机系统中大量联机信息的保存者。在存储器管理和设备管理中，硬盘又被作为内存的补充，实现虚拟存储器和虚拟设备的管理

## 程序的装入与链接

​	用户用高级语言编写的源程序，需要经过编译、链接和装入之后，才能被处理器运行。

* **编译**将用户用高级语言编写的源程序转换为目标模块；
* **链接**将用户程序需要的所有目标模块链接在一起，形成一个可执行模块，即装入模块；
* **装入**将装入模块放入内存

### 地址



​	在程序装入内存前，装入模块中给出的程序地址为程序的逻辑地址或相对地址。一个用户作业的所有装入模块的逻辑地址集合称为该作业的逻辑地址空间。

​	当用户作业被装入内存后，其物理地址由用户作业所对应的进程物理地址体现，进程物理地址的总体构成了用户程序实际运行的物理地址空间。

​	为了保证用户作业的正确运行，必须把用户作业的逻辑地址转换为物理地址，这一工作由操作系统的存储管理单元（MMU）在作业装入内存的过程中完成，称为**地址变换**或**重定位**。

#### 逻辑地址

​	逻辑地址是指由程序产生的与段相关的偏移地址部分。由CPU所生成的地址。逻辑地址是内部和编程使用的、并不唯一。也称为虚拟地址。如C语言中的&操作（取地址），得到的是相对于当前进程数据段的地址（偏移地址），与物理地址无关。

#### 物理地址

​	在操作系统中，存储器管理功能负责为进程分配和回收内存，实现内存空间在时间和空间上的复用，在某一进程结束或撤销后，进程的内存空间可以由其它进程覆盖；		

​	从内部结构上看，计算机存储器由大量的字节阵列或字阵列组成，每个字节或字都有自己的地址，要访问存储器中的信息必须知道信息的地址。计算机的内存也称为物理内存，其地址从最低开始到最高上界，按照顺序编号，是一个一维线性存储空间。

​	内存中的地址称为物理地址。  物理地址就是物理存储器实际的寻址范围。

#### 地址空间

​	地址空间是一个进程可用于寻址内存的一套地址集合，并且这个地址空间独立于其他进程的地址空间（除了在一些特殊情况下进程需要共享它们的地址空间外）。      

​	当内存空间占满时，通过外存与内存的对换实现内存空间的虚拟扩充（虚拟空间）。存储器管理在提供多进程共享内存的同时，还通过可靠的隔离机制阻止一个进程读写另一个进程的内存，实现内存地址空间的保护。

### 程序链接

​	链接是将用户程序所需要的所有目标模块链接在一起的过程。

1. 静态链接

    > ​	静态链接指链接过程在程序装入内存前完成并形成整个程序的逻辑地址空间。
    >
    > ​	通常，由编译产生的所有目标模块的起始地址可能都是从0开始，每个模块中的程序代码地址都是相对于模块的起始地址。     例如，如果一个用户作业由3个目标模块A、B、C组成，长度分别为m、n、k，每个模块在链接前的起始地址都从0开始，
    >
    > ​	经过静态链接后，模块A、B和C被链接为一个大的模块，原来的模块B和C的起始地址根据模块A的地址进行了调整，分别为m和m + n.

2. 装入时动态链接

    > ​	装入时动态链接将目标模块的链接过程放在这些目标模块装入内存的过程中完成。目标模块在装入内存时，采用边装入边链接的方式。
    >
    > ​	优点：
    >
    > 1. 便于模块的修改和更新
    >     * 静态链接会使得系统每次修改或更新某个模块，都要重新完成所有模块的链接。装入时动态链接，只要模块没有装入内存，系统都可以随时修改和更新模块。
    > 2. 便于实现目标模块的共享
    >     * 静态链接只要有某个目标模块被多个模块共享，会多次链接该目标模块，装入内存后，在内存中存在共享模块的多个副本。而装入时动态链接将共享模块只放一个版本在内存中，节约了内存，实现了真正的模块共享。
    >
    > 

3. 运行时动态链接

    > ​	运行时动态链接是一种较先进的链接方式，在程序装入内存时不链接模块，将链接过程推迟到程序运行时进行。在程序运行过程中，若发现被调用的某个模块尚未装入内存，操作系统找到该模块，将其装入内存，同时链接到调用模块上。
    >
    > ​	运行时动态链接的优点除了具有装入时动态链接的优点外，还可以做到**不运行的模块，不需要链接**。与静态链接和装入时动态链接相比，更节约内存。静态链接和装入时动态链接都需要将程序的全部目标模块进行链接，使得某些在运行时不需要的目标模块也进行了链接，造成了内存空间的浪费。

### 程序装入

​	目标模块放入内存的过程为装入过程。

装入方式

1. 绝对装入方式、

    > ​	在编译前程序员写源程序的时候如果知道程序所对应的进程驻留在内存中的物理地址，则链接会按照模块在内存中的物理地址生成逻辑地址，装入程序根据装入模块中的逻辑地址将程序装入内存，这样的装入方式称为绝对装入方式。绝对装入方式下程序的逻辑地址和物理地址相同。
    >
    > ​	绝对装入方式对程序员的要求很高。程序员在编程时必须熟悉内存的使用情况，知道程序的物理地址，能够在内存中调整程序和数据的地址。
    >
    > ​	绝对装入方式适合用于实时操作系统和嵌入式操作系统，其他的操作系统很少采用。

2. 静态重定位装入方式

    > ​	静态重定位装入方式将程序装入内存时，**系统根据内存当时的实际使用情况，将装入模块装入到内存的适当位置。**
    >
    > ​	“重定位”是指程序在内存中的物理地址不再是原来程序的逻辑地址，而是根据内存的情况被重新定位。  
    >
    > ​	“静态”指的是用户程序从逻辑地址到物理地址的变换过程在程序执行前完成，在执行期间不再改变。如果物理地址要发生改变，则需要进行重新装入。 
    >
    > ​	   优点：
    >
    > 1. 实现简单，从逻辑地址到物理地址变换不需要专门的硬件便能完成；
    >
    > 2. 可用于多道程序环境。
    >
    >     缺点：
    >
    > 1. 程序在执行过程中不能在内存中移动。

3. 动态重定位装入方式

> ​	动态重定位装入方式可以使程序运行时，CPU访问内存前，重新定位程序在内存中的地址，实现内存管理的灵活性，提高内存空间的利用率
>
> ​	优点：
>
> 1. 目标模块装入内存时无需任何修改，因而装入之后再搬迁也不会影响其正确执行，这对于存储器紧缩、解决碎片问题是非常有利的；
>
> 2. 一个程序由若干个相对独立的目标模块组成时，每个目标模块各装入一个存储区域，这些存储区域可以不是顺序相邻的，只要各个模块有自己对应的定位寄存器就行。
>
>     
>
> 缺点：	实现过程中需要附加硬件（重定位寄存器）支持，内存管理更加复杂。

---

​	在操作系统中，存储器管理功能负责为进程分配和回收内存，实现内存空间在时间和空间上的复用，在某一进程结束或撤销后，进程的内存空间可以由其它进程覆盖

​	达到两个目标:

1. 地址独立：程序发出的地址应与物理主存地址无关
2. 地址保护：一个进程不能访问另一个进程的地址空间

## 连续分配方式

​	为一个用户程序分配一个连续的内存空间。

 1. 单一连续分配

    * 应用于单道编程

    * > 最简单的存储管理方式
        >
        > 内存分为：系统区和用户区
        >
        > 缺点：
        >
        > 1. 将整个程序加载到内存空间
        > 2. 浪费资源 (CPU 和 Memory)

 2. 固定分区分配

    * 应用于多道编程

    * > 多道编程中最简单的内存管理方式
        >
        > 1. 将内存划分为几个固定的区域，可同时装入多个作业/任务
        >
        > 2. 程序被加载到固定的分区
        >
        > 将分区按大小排队，并将其地址、分配标识做记录
        >
        > 与单一连续分配方式比较，固定分区分配方式使得系统的资源利用率和吞吐量有一定程度的提高。
        >
        > 缺点：
        >
        > 1. 内存利用率不高      由于分区大小固定，装入进程的大小受到限制。超过最大分区的进程，只有采用覆盖技术才能在内存中运行，降低了系统的运行效率；较小的进程，造成内存“碎片”（内碎片、内零头），降低了内存的利用率。
        > 2. 划分分区大小困难      划分分区的大小对系统性能有很大影响，合理划分分区的大小很困难。
        > 3. 需要预先知道进程大小      固定分区分配方式适合进程大小已知的情况，如果进程大小不知或进程大小变化很大，则采用固定分区分配不是特别适合。

 3. 可变分区分配

    * 应用于多道编程

        * > ​	根据作业的实际需要，动态地为之分配内存空间不在系统初始化时进行分区划分，而在每个用户作业装入内存时，根据作业的大小和内存的使用情况，动态划分分区并分配。克服了固定分区分配的内存利用率低的问题，更适合多道程序环境。
            >
            > ​	为了完成有效分配和回收分区，需要构建对分区信息进行描述的数据结构，并在已知分区数据结构的基础上完成分区分配算法与回收方法。
            >
            > ​	空闲分区表：包括分区序号、分区始址、分区大小等
            >
            > ​	空闲分区链：空闲分区链是空闲分区最常用的组织形式，操作系统将所有的空闲分区通过前向和后向指针串在一起组成双向空闲分区链。

            

 4. 覆盖与交换（动态重定位分区分配）

#### 可变分区分配：基于顺序搜索

##### 1. 首次适应法first fit，FF

首先将空闲分区按照地址递增的顺序组织成空闲分区链。为作业分配内存时，系统根据作业大小，从空闲分区链的第一个空闲分区开始查找，只要找到第一个满足作业大小的空闲分区，从该空闲分区中分割一部分分配给作业，另一部分仍作为空闲分区；如果空闲分区链全部查找完也不能满足作业要求，则系统不能为作业分配内存。

缺点：

1. 系统每次都是从链首开始查找空闲分区，低地址段的大空闲分区被分配或被分割，剩下了小空闲分区或空闲分“碎片”；
2. 系统每次从链首开始查找空闲分区，增加查找开销。

##### 2. 循环首次适应算法next fit，NF

​	将空闲分区按照地址递增的顺序组织成空闲分区链。为作业分配内存时，系统不是从空闲分区链的第一个空闲分区开始查找，而是从空闲分区链上，上次为作业分配分区后的位置开始查找，找到第一个满足作业大小的空闲分区，分割并分配该空闲分区。如果找到空闲分区链的链尾还没有找到，系统可以再从链首开始查找。

优点：克服了首次适应算法的缺点，使得空闲分区的分布更加均匀，查找空闲分区所需要的时间更短，

缺点：空闲分区链中的小分区或“碎片”问题仍然不能解决



##### 3. 最佳适应算法best fit，BF

​	空闲分区链需要按照分区大小递增的顺序组织扫描整个空闲分区链，从中挑选出一个满足进程要求的最小分区进行分配，因此，被分配的空闲分区是大小最适合的分区。避免分割大空闲分区，使得内存“碎片”更小。

​	该算法克服了FF算法和NF算法的缺点，是一种较优的分区分配算法。该算法由于找到的空闲分区是最小能够满足要求的分区，剩余的空闲分区很小，这一部分很小的“碎片”，难以再次利用。

##### 4. 最坏适应算法worst fit，WF

​	空闲分区链需要按照分区大小递减的顺序组织，

每次从链首最大的分区开始分配，挑选满足作业要求的最大分区，使得分配的空闲分区分配给作业后剩下的部分比较大，能够再作为空闲分区进行分配。减少了内存中“碎片”的大小和个数。

优点：查找效率高

缺点：该算法存在的问题是最后会导致系统缺乏较大的空闲分区。



#### 可变分区分配：基于索引搜索

##### 5. 快速适应算法quick fit，QF

​	将空闲分区根据进程常用空间大小进行分类，并单独设立空闲分区链。

​	内存中设立一张管理索引表，每一个表项对应了空闲分区类型

​	空闲分区管理索引表有每个空闲分区链的长度范围和开始指针。为作业分配内存时，首先根据作业大小查找空闲分区管理索引表，得到空闲分区链的起始指针，然后再从相应的空闲分区链中为作业分配一个空闲分区

​	该算法的**优点**是能够快速得到空闲分区，查找效率高，不会分割空闲分区，并能够保留大的空闲分区，对大的作业也不会产生内存“碎片”。该算法的**缺点**是回收分区较困难，算法复杂，系统的开销较大。

#### 可变分区分配与回收

​	分区分配：分区分配操作首先根据分配算法从空闲分区表中查找所需大小的分区，如果用户进程的大小为u.size，空闲分区的大小为m.size，则m.size与u.size之差为分配后的剩余部分size，首次适应法和循环首次适应法只需要该差值大于0即可，最佳适应法需要该差值为最小，最差适应法需要该差值为最大。如果能够分配分区，则分区分配成功后会将分配区的首址返回给分配过程的调用者。

​	分区回收当作业完成时会释放内存，系统需要回收为作业分配的内存，回收的内存需要进入空闲分区链中才能被再次分配。根据回收区的首址，采取不同的回收方法。

1. 上邻空闲区：合并，修改大小
2. 下邻空闲区：合并，修改大小、首址
3. 上、下邻空闲区：合并，修改大小
4. 不邻接：则建立一新表项，插入空闲链的适当位置。

#### 动态可重定位分区分配

​	紧凑/拼接/紧缩 compaction通过作业移动将原来分散的小分区拼接成一个大分区，拼接时要耗费较多的时间。作业的移动需重定位。只有重定位是动态的时候，才有可能进行紧缩，紧缩在执行时期进行I/O problem1. Latch job in memory while it is involved in I/O.（当I/O的时候，把作业锁定在内存中。）2. Do I/O only into OS buffers.（只在操作系统的缓冲区进行I/O。）

#### 交换/对换（swapping）

​	把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据调入内存。

	1. 是提高内存利用率的有效措施

对换类型：

1. 整体对换（中级调度）：以整个进程为单位，也称“进程对换”，解决内存紧张
2. 部分对换（分页/分段对换）：以页或段为单位，也称页面对换/分段对换：提供虚存支持。

为实现进程对换，系统须实现三方面功能：

1. 对换空间的管理

    > 外存分为：文件区和对换区    
    >
    > 文件区侧重存储空间利用率，对换区侧重于换入换出速度。
    >
    > 因此，文件区一般采用离散分配方式，对换区一般采用连续分配方式。采用数据结构和分配回收类似于动态分区分配。

2. 进程的换出

    > 选择被换出进程：      
    >
    > 考虑因素：进程状态，优先级，驻留时间
    >
    > 换出过程： 对于共享段：计数减1， 是0则换出，否则不换 修改PCB

3. 进程的换入

    > 选择换入进程：进程就绪，优先级，换出时间等。申请内存。

换系统中，进程的进入和退出留下一个可用内存空间的混杂区有些区域可能太小而无法利用，外部碎片

#### 覆盖

让进程比它所分配到的内存空间大，可以使用覆盖（overlay）技术。覆盖的思想是在任何时侯只在内存中保留所需的指令和数据。当需要其他指令时，将其装入到不再需要的指令所占用的内存空间。

## 基本分页存储管理方式

​	将物理内存分配成固定大小的块 (或页框)固定单元易于分配任何空闲物理页可以存储任何逻辑页

​	将逻辑地址空间分成相同大小的页（或页面）每个逻辑页可以存在物理内存中或者倒出到磁盘上

​	进程通过逻辑地址访问内存每个逻辑地址引用被MMU翻译成物理内存地址

​	页面大小页太大：页内碎片大页太小：进程页表很长，占用大量内存；换入/换出效率低页面大小应适中，是2的幂，一般1kB~8kB

### 页表 

* 页表是分页系统中的关键组件
* 用于实现逻辑页面到物理页面的地址映射（MMU 用页表执行地址翻译）

### 地址变换机构

* 实现从逻辑地址到物理地址的转换

* 系统设置一个页表寄存器(page-table register, PTR)，存放页表在内存的首址和页表长度。



### 快表

* 具有并行查寻能力的特殊高速缓冲寄存器

* 加快了内存访问速度，缓存了从虚拟页面到物理页面的映射

使用过程

> 1. 在使用快表的情况下，当处理器给出进程的逻辑地址后，从逻辑地址中得到页号，地址变换机构查询快表，如果该页已在快表中，从快表得到物理块号；
> 2. 如果该页不在快表中，再查询内存中的页表，得到物理块号，同时将该页信息写入快表以便以后使用；
> 3. 如果此时快表已满，处理器需要将快表中不需要的表项换到内存页表中再写入快表。



### 分页存储管理的优缺点

#### 优点

1. 简单的内存分配 
2. 可以共享许多小片地址空间
3. 容易增长地址空间
4. 没有外碎片，每个内碎片不超过页的大小。
5.  一个程序不必连续存放。
6.  便于改变程序占用空间的大小(主要指随着程序运行而动态生成的数据增多，要求地址空间相应增长，通常由系统调用完成而不是操作系统自动完成)。

#### 缺点

页表的尺寸可能很大

1. 程序要全部装入内存。
2. 采用动态地址变换机构会增加计算机的成本和降低处理机的速度。
3.  各种表格要占用一定的内存空间，而且要花费一定的时间来建立和管理这些表格。 
4.   存储扩充问题没有得到解决。  
5.  不便于动态连接。 
6. 不易实现共享（相对于段式存储管理）。

### 两级或多级页表

* 把页表分成2个或更多个级
    * 一级页表总是驻留在内存
    * 二级页表在需要的时候放入内存

一级页表存放二级页表的信息，二级页表存放三级页表的信息 最后一级页表存放的才是逻辑页面到物理页面的映射

#### 两级页表

​	为了能够快速查找页表页面在内存中的物理块号，这些页表页面设计有一个地址索引表，即页目录表（外部页表）页目录表的表项为每个页表页面所在的内存物理块号和相关信息      这样，系统将页表分为了两级：一级为页目录表，二级为页表页面。页表页面中的每项是每个页面所在的页号和物理块号

两级页表的逻辑地址被划分为三部分：	

1. 页目录
    1. 由页目录表（一级页表）在内存中的起始地址加上页目录号（即需要查找的页表某页在页目录中的编号）,得到页表某页的物理块号；
2. 页表页
    1. 通过页表某页的物理块号得到页表页（二级页表中的一页），由页表页号（某页在页表页中的编号）查询该页表页项（二级页表中的一页），得到对应的物理块号；
3. 页表页内
    1. 将该物理块号加上页表页内号（页内偏移）则为所需要的物理地址。





## 基本分段存储管理方式

分段管理把一个程序按照逻辑单元分成多个程序段（逻辑分段）连续的逻辑内存空间区域，每个段定义一组逻辑信息

每一个段使用自己单独的虚地址空间独立的逻辑单位, 比如数据, 代码, 栈等

纯粹分段中整个程序占有一个虚拟地址空间

> 好处：方便编程；信息共享；信息保护；动态链接；动态增长（如数据段的增长）。



## 虚拟存储器的基本概念

将外存作为内存的补充，从逻辑上扩充内存

概念：在具有层次结构存储器的计算机系统中，采用自动实现部分装入和部分对换功能，为用户提供一个比物理内存容量大得多的，可寻址的一种“内存储器”。

### 局部性原理

1. 程序中只有少量分支和过程调用，大部分是顺序执行的，即要执行的下一条指令紧跟在当前执行指令之后。 
2. 程序往往包含若干个循环，这些是由相对较少的几个指令重复若干次组成的，在循环过程中，计算被限制在程序中一个很小的相邻部分中（如计数循环）。
3. 很少会出现连续不断的过程调用序列，相反，程序中过程调用被限制在一个小的范围内，因而，一段时间内，指令引用被局限在很少几个过程中。
4. 对于连续访问数组之类的数据结构，往往是对存储区域中的数据或相邻位置的数据（如动态数组）的操作。 
5. 程序中有些部分是彼此互斥的，不是每次运行时都用到的，例如，出错处理程序，仅当在数据和计算中出现错误时才会用到，正常情况下，出错处理程序不放在内存，不会影响整个程序的运行。

### 虚拟存储器特征

* 多次性
    * 最重要的特征   虚拟存储器在实现上需要将一个作业分多次调入内存运行。
* 对换性   
    * 虚拟存储器允许作业在运行过程中将暂时不运行的部分换出，在需要时再换入，对换性使得作业运行所需内存更少，系统的多道度提高。
* 虚拟性  
    *  虚拟存储器从逻辑上扩充内存容量，使得用户能够使用的内存容量远远大于实际内存容量，提高了系统运行程序的能力。

### 虚拟地址

计算机系统的可寻址范围为虚拟存储器的最大范围

## 虚拟存储管理方式

### 请求分页方式

#### 优点：

1. 作业的程序和数据可以按页分散存放在内存中，减少了移动的开销，有效地解决了碎片问题；
2. 由于采用请求分页虚存管理，用户可用的内存空间大大扩展，既有利于改进内存利用率，又有利于多道程序运行。

#### 缺点：

1. 要有一定硬件支持，要进行缺页中断处理，成本增加，系统开销加大;
2. 页内会出现碎片，如果页面较大，则内存的损失仍然较大。



以页为单位置换

需求：

1. 硬件支持
    1. 请求分页的页表机构（页表中增加用于请求分页的控制位）
    2. 缺页中断机构（待访问页面不在内存中，产生缺页中断）
    3. 地址变换机构（查询/修改快表、页表，修改控制位，缺页中断处理）

2. 软件支持
    1. 用于实现请求调页的软件
    2. 实现页面置换的软件

内存管理单元MMU（Memory Management Unit）

请求分页虚拟存储系统是将作业信息的副本存放在磁盘中，当作业被调度投入运行时，并不把作业的程序和数据全部装入内存，而仅仅装入即将使用的那些页面，在执行过程中访问到不在内存的页面时，再把它们动态地装入。



#### 页面置换算法存储管理

1. 最佳置换算法

    > 最佳置换算法（Belady算法）选择一个不再访问或最长时间不会被访问的页面进行替换
    >
    > 

2. LRU (least recently used) 置换算法

    > 替换一个最近最久未被访问的旧页面

3. FIFO (first in first out) 先进先出页面置换算法

    > 更换最早进入内存的页面（替换当前内存中存在时间最久的页面）

4. 第二次机会页面置换算法

5. 时钟置换（clock）

### 请求分段存储管理



### 段页式虚拟存储管理





# 6. *设备管理

## I/O

操作系统中负责管理输入输出设备的部分称为I/O系统

I/O系统管理的主要对象是：

1. I/O设备
2. 相应的设备控制器
3. I/O操作有关的软硬件

目的：

1. 完成用户提出的I/O请求
2. 提高I/O速率
3. 提高设备的利用率
4. 为更高层的进程方便地使用这些设备提供手段。

### I/O 设备

#### 分类

1. 按设备使用特性分类：
    1. 存储设备，外存或辅助存储器
    2. 输入输出设备，包括输入设备、输出设备、交互式设备
2. 按信息交换单位分类:
    1. 块设备，以数据块为单位存储和传输数据，数据块可寻址，	如磁盘（DMA方式）
    2. 字符设备，以字符为单位存放和传输数据，字符是不可寻址的，如交互式终端，打印机等（中断驱动方式）
3. 按设备的共享属性分类
    1. 独占设备，即临界资源
    2. 共享设备，可寻址和可随机访问的设备，如磁盘
    3. 虚拟设备，通过虚拟技术把一台独占设备变换为若干台逻辑设备（spooling技术）
4. 按从属关系分类
    1. 系统设备：计算机系统标准设备
    2. 用户设备：用户自行安装配置后由OS统一管理的设备
5. 按传输速率分类：
    1. 低速设备：如键盘、鼠标中速设备：如打印机
    2. 高速设备：如磁带、磁盘、光盘

### 设备控制器

设备控制器是计算机中的一个实体（IO设备的电子部分）

1. 控制一个或多个I/O设备
2. 实现设备和计算机之间的数据交换
3. 也称为适配器（adapter），是CPU和I/O设备之间的接口
4. 通常是一块印刷电路板，也叫接口卡

#### 基本功能

1. 接收和识别处理器命令      设备控制器具有控制（命令）寄存器和命令译码器，将处理器的命令接收到控制寄存器中并对命令进行译码。
2. 数据交换      具备数据寄存器。实现处理器与设备控制器之间（数据总线）、设备控制器与设备之间的数据交换。
3. 了解和报告设备的状态      设备控制器中的状态寄存器能够存储接收到的设备状态信息，并将信息上传给处理器。
4. 识别设备地址      配置地址译码器。系统中的每一个设备都有一个地址,设备控制器能够识别所控制设备的地址。
5. 数据缓冲      设备控制器中设置缓冲以解决I/O设备与CPU速度不匹配的问题。
6. 差错控制      设备控制器兼管从设备传送来的数据差错检查，保证数据的正确性。

### I/O通道

#### 通道概念

​	通道是一种特殊的执行I/O指令的处理机，用于代替处理器实现外部设备的输入/输出操作和管理，实现外部设备与处理器的并行操作。

引入目的：解脱CPU对I/O的组织和管理，建立独立的I/O操作。

采用通道后计算机系统可以实现三级并行：

1. 通道与处理器并行执行，
2. 通道与通道之间并行操作，
3. 不同通道上的外围设备并行操作。

因此，通道使得系统的并行工作能力大大提高。

#### 通道类型

按照信息交换方式和设备连接方式的不同，通道分为

1. 字节多路通道

    > 连接设备控制器的每个子通道，以字节为单位，分时共享方式传输数据，主要连接大量**低速**外围设备，如终端、打印机。

2. 数组选择通道

    > 选择通道每个子通道以一组数据为单位，对一个子通道而言，传送效率更高。
    >
    > 数组选择通道在一段时间内只能执行一个通道程序，只允许一台设备进行数据传输。当一台设备数据传输完成后，再选择另一个子通道的设备进行数据传输。
    >
    > 主要用于连接磁盘等高速输入/输出设备。

3. 数组多路通道

    > 结合了数组选择通道传送速度高和字节多路通道能进行分时并发传送多个设备数据的优点
    >
    > 数组多路通道主要用于连接高、中速设备。

### I/O控制方式

1. 可编程 I/O 是最简单的

    > CPU 等待 I/O 完成
    >
    > 这种模式称为轮询或者繁忙等待 
    >
    > 性能低，编程简单

2. 中断驱动 I/O 是最常用的

    > CPU 初始化 I/O并启动第一次I/O操作
    >
    > CPU 去忙别的事情
    >
    > I/O完成时, CPU 将被中断
    >
    > CPU 处理中断
    >
    > CPU 恢复被中断的程序

3. 直接内存访问I/O 用于改进效率

    > 数据传输的基本单位是块
    >
    > 用 DMA 控制器处理 I/O 中断
    >
    > 降低CPU响应中断的频率
    >
    > **DMA控制器组成**
    >
    > 1. 主机与DMA控制器接口
    > 2. DMA控制器与块设备接口
    > 3. I/O控制逻辑

4. I/O通道控制方式

    > 把对一个数据块为单位的读写干预减少为对一组数据块的读写及有关的控制和管理为单位的干预
    >
    > I/O通道控制方式，CPU只需给出：
    >
    > 1. 通道程序首址
    > 2. 要访问I/O设备后，通道程序就可完成一组块操作
    > 3. 通道是通过执行通道程序并与设备控制器共同实现对I/O设备的控制的

## DIsk







# 7. *文件系统管理

























# 8. 操作系统安全

































