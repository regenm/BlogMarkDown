---
title: C/C++大型项目编程注意事项
date: 2024-05-13 14:43:31
tags: [C/C++,编程规范,项目]
---

**C/C++大型项目编程规范**

​	最近在参与（或者说使用）某些项目的代码时，感觉其代码之简洁精炼，语言习惯之规范，外观之整洁，可读性之高令人赏心悦目。

​	在其基础上进行增删改查后总是觉得自己的代码不够优雅，就好像一篇书法作品中掺杂几行我写的字。

​	于是打算学习C/C++项目编程规范，不求优雅，只求规整可读，结构合理。

​	基于华为C语言编程规范 [在线wiki文档](https://ilcc.gitbooks.io/wiki/content/StyleGuide/Huawei-C/index.html)

# 代码总体原则

## 1、清晰第一

**代码的可阅读性高于性能，只有确定性能是瓶颈时，才应该主动优化**

* 优秀的代码可以自我解释（以我的水平可能做到比较难）

* 常写注释，并且注释写的清晰

## 2、简洁为美

**写的代码越多，意味着出错的地方越多，也就意味着代码的可靠性越低。**

# 术语

> 原则：编程时必须坚持的指导思想。
>
> 规则：编程时强制必须遵守的约定。
>
> 建议：编程时必须加以考虑的约定。
>
> 说明：对此原则/规则/建议进行必要的解释。
>
> 示例：对此原则/规则/建议从正、反两个方面给出例子。
>
> 延伸阅读材料：建议进一步阅读的参考材料。

# 头文件

**不合理的头文件布局是编译时间过长的根因，不合理的头文件实际上不合理的设计。**

如果引入了新的依赖，则一旦被依赖的头文件修改，任何直接和间接依赖其头文件的代码都会被重新编译。



## 原则1.1 头文件中适合放置接口的声明，不适合放置实现

头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。

* 内部使用的函数（相当于类的私有方法）声明不应放在头文件中
* 内部使用的宏、枚举、结构定义不应放入头文件中。
* 变量定义不应放在头文件中，应放在.c文件中。

否则多次依赖会重复定义

* 变量的声明尽量不要放在头文件中，亦即尽量不要使用全局变量作为接口。变量是模块或单元的内部实现细节，不应通过在头文件中声明的方式直接暴露给外部，应通过函数接口的方式进行对外暴露。即使必须使用全局变量，也只应当在.c中定义全局变量，在.h中仅声明变量为全局的。

## 原则1.2 头文件应当职责单一。

## 原则1.3 头文件应向稳定的方向包含。

说明：头文件的包含关系是一种依赖，一般来说，应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块。

## 规则1.1 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口。

说明：如果一个.c文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如main函数所在的文件。

## 规则1.2 禁止头文件循环依赖

​	任何一个头文件的改变都会使得循环中的所有头文件重新编译

## 规则1.3 .c/.h文件禁止包含用不到的头文件。

## 规则1.4 头文件应当自包含。

>"头文件应当自包含"是指头文件应该包含自身所需的所有内容，而不依赖于其他头文件。这样的头文件通常被称为"自包含头文件"。下面解释一下这个概念的意义：
>
>1. **独立性和可移植性**：自包含头文件使得头文件本身更加独立，不依赖于其他头文件。这样做有助于提高代码的可移植性，因为当你在其他项目或环境中使用这个头文件时，不需要担心它依赖的其他头文件是否可用。
>2. **简化依赖关系**：自包含头文件可以简化代码的依赖关系。如果一个头文件依赖于另一个头文件，而后者又依赖于其他头文件，这会形成复杂的依赖链。通过自包含头文件，可以减少这种依赖链，提高代码的可维护性。
>3. **避免重复包含**：自包含头文件通常会包含预处理器指令来避免重复包含。这样可以确保在包含相同头文件多次时不会导致重复定义的问题。
>4. **提高效率**：自包含头文件可以减少预处理器的工作量，因为它们不需要解析其他头文件的内容。这有助于提高编译效率。

## 规则1.5 总是编写内部#include保护符（#define 保护）。

所有头文件都应当使用#define 防止头文件被多重包含，命名格式为`FILENAME_H`，为了保证唯一性，更好的命名是`PROJECTNAME_PATH_FILENAME_H`。

## 规则1.6 禁止在头文件中定义变量。

说明：在头文件中定义变量，将会由于头文件被其他.c文件包含而导致变量重复定义。

## 规则1.7 只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量。

## 规则1.8 禁止在extern "C"中包含头文件。

> `extern "C"` 是用于在 C++ 中声明 C 函数时的一种语法。它告诉编译器这些函数按照 C 语言的约定进行链接。
>
> 在 C++ 中，函数名的重载、名称修饰（name mangling）等特性会导致函数名在编译后被修改，这样的函数名在链接时可能无法与 C 代码中的函数名匹配。为了解决这个问题，C++ 提供了 `extern "C"`，它告诉编译器不要对函数名进行 C++ 风格的名称修饰，而是按照 C 语言的规则进行链接。

# 函数

函数设计的精髓：编写整洁函数，同时把代码有效组织起来。

整洁函数要求：代码简单直接、不隐藏设计者的意图、用干净利落的抽象和直截了当的控制语句将函数有机组织起来。

代码的有效组织包括：逻辑层组织和物理层组织两个方面。逻辑层，主要是把不同功能的函数通过某种联系组织起来，主要关注模块间的接口，也就是模块的架构。物理层，无论使用什么样的目录或者名字空间等，需要把函数用一种标准的方法组织起来。例如：设计良好的目录结构、函数名字、文件组织等，这样可以方便查找。



## 原则2.1 一个函数仅完成一件功能。

说明：一个函数实现多个功能给开发、使用、维护都带来很大的困难。

将没有关联或者关联很弱的语句放到同一函数中，会导致函数职责不明确，难以理解，难以测试和改动。

## 原则2.2 重复代码应该尽可能提炼成函数

说明：重复代码提炼成函数可以带来维护成本的降低。

可以使用代码重复度检查工具

## 规则2.1 避免函数过长，新增函数不超过50行（非空非注释行）。

## 规则2.2 避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层。

### 减少代码嵌套层数的方法

>1. **使用函数抽象**：将嵌套的代码块提取成独立的函数，以便于重用和理解。
>
>```
>python复制代码def main_function():
>    if condition:
>        process_items(items)
>    else:
>        handle_condition_not_met()
>
>def process_items(items):
>    for item in items:
>        if item_valid(item):
>            process_item(item)
>        else:
>            handle_invalid_item(item)
>
>def item_valid(item):
>    return item.condition
>
>def process_item(item):
>    # 处理item
>    pass
>
>def handle_invalid_item(item):
>    # 处理无效item
>    pass
>
>def handle_condition_not_met():
>    # 处理条件未满足情况
>    pass
>```
>
>1. **使用早期返回**：在函数内部，尽早返回结果，而不是在多层嵌套中处理。
>
>```
>python复制代码def main_function():
>    if not condition:
>        handle_condition_not_met()
>        return
>    
>    for item in items:
>        if not item_valid(item):
>            handle_invalid_item(item)
>            continue
>        process_item(item)
>
>def item_valid(item):
>    return item.condition
>
>def process_item(item):
>    # 处理item
>    pass
>
>def handle_invalid_item(item):
>    # 处理无效item
>    pass
>
>def handle_condition_not_met():
>    # 处理条件未满足情况
>    pass
>```
>
>1. **使用异常处理**：适用于处理特殊情况或错误的情况。
>
>```
>python复制代码def main_function():
>    try:
>        if condition:
>            for item in items:
>                process_item(item)
>        else:
>            raise ConditionNotMetError
>    except ConditionNotMetError:
>        handle_condition_not_met()
>
>def process_item(item):
>    if not item_valid(item):
>        raise InvalidItemError
>    # 处理item
>
>def item_valid(item):
>    return item.condition
>
>def handle_condition_not_met():
>    # 处理条件未满足情况
>    pass
>
>class ConditionNotMetError(Exception):
>    pass
>
>class InvalidItemError(Exception):
>    pass
>```
>
>这些方法可以帮助将嵌套降低到合理的水平，使代码更易读、更易维护。

## 规则2.3 可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护。

可能用不到。

说明：可重入函数是指可能被多个任务并发调用的函数。在多任务操作系统中，函数具有可重入性是多个任务可以共用此函数的必要条件。共享变量指的全局变量和static变量。

## 规则2.4 对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组/模块内应统一规定。缺省由调用者负责。

## 规则2.5 对函数的错误返回码要全面处理。

## 规则2.6 设计高扇入，合理扇出（小于7）的函数。

说明：扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。

建议2.1 函数不变参数使用const。

建议2.2 函数应避免使用全局变量、静态局部变量和I/O操作，不可避免的地方应集中使用。

建议2.4 函数的参数个数不超过5个。

建议2.5 除打印类函数外，不要使用可变长参函数。

# 3 标识符命名与定义
